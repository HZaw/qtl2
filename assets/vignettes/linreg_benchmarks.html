<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>R/qtl2: Benchmarks of linear regression routines</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>R/qtl2: Benchmarks of linear regression routines</h1>

<p><a href="https://github.com/kbroman/qtl2">R/qtl2</a> includes code with several
options for linear regression. We&#39;re mostly focusing on using the
<a href="http://eigen.tuxfamily.org">Eigen library</a> via
<a href="https://github.com/RcppCore/RcppEigen">RcppEigen</a>, particularly
linear regression via QR decomposition with column pivoting. We want
speed, but we often have to deal with rank-deficient matrices.</p>

<p>In addition to routines that return coefficient estimates and
estimated standard errors (SEs), we also have routines that return
just the residual sum of squares (RSS), as for the calculation of LOD
scores, that&#39;s all that matters. We might perform a lot of
regressions, getting just the RSS as a measure of quality-of-fit, and
then go back to the interesting cases to look at the full set of
coefficients and SEs.</p>

<p>Here, we present a few benchmarks comparing a couple of different
routines from the <a href="http://eigen.tuxfamily.org">Eigen library</a>
(QR decomposition with column pivoting and Cholesky decomposition; the
latter doesn&#39;t handle the rank-deficient case). We compare these to
the <a href="http://www.netlib.org/lapack/">LAPACK</a> routines used in
<a href="http://rqtl.org">R/qtl</a>:
<a href="http://www.netlib.org/lapack/explore-html/d8/dde/dgels_8f.html"><code>dgels</code></a>
and
<a href="http://www.netlib.org/lapack/explore-html/d6/d4b/dgelsy_8f.html"><code>dgelsy</code></a>.
We also consider R&#39;s <code>lm.fit</code>, which is the workhorse behind <code>lm</code>.</p>

<p>These linear regression functions are not exported, so we need to use
<code>qtl2:::</code>.</p>

<h2>Simple case</h2>

<p>First let&#39;s look at a simple case, of a single covariate.</p>

<pre><code class="r">set.seed(27343534)
n &lt;- 1000
x &lt;- rnorm(n, 50, 10)
X &lt;- cbind(1, x)
y &lt;- 30 + 0.5*x + rnorm(n, 0, 2.5)
Y &lt;- as.matrix(y)
</code></pre>

<p>We use the
<a href="http://cran.r-project.org/web/packages/microbenchmark/">microbenchmark package</a>
and run each of the routines 1000 times.</p>

<pre><code class="r">library(qtl2)
library(microbenchmark)
microbenchmark(lmfit =        lm.fit(X, y),
               dgels=         qtl2:::calc_rss_lapack(X, Y),
               dgelsy=        qtl2:::calc_rss_lapack(X, Y, skip_dgels=TRUE),
               eigen_qr_rss=  qtl2:::calc_rss_eigenqr(X, y),
               eigen_qr=      qtl2:::fit_linreg_eigenqr(X, y),
               eigen_chol_rss=qtl2:::calc_rss_eigenchol(X, y),
               eigen_chol=    qtl2:::fit_linreg_eigenchol(X, y),
               times=1000)
</code></pre>

<pre><code>## Unit: microseconds
##            expr    min     lq   mean median     uq     max neval cld
##           lmfit 139.46 148.80 172.57 152.58 159.52  4560.6  1000   c
##           dgels  56.61  61.93  67.23  64.29  66.61  1174.7  1000 ab 
##          dgelsy  75.50  81.18 122.26  83.66  86.95 36324.0  1000  bc
##    eigen_qr_rss  46.64  50.58  54.06  52.59  55.54   175.2  1000 a  
##        eigen_qr  55.84  59.29  70.04  61.55  65.21  1272.8  1000 ab 
##  eigen_chol_rss  42.30  45.59  49.65  47.71  50.78   146.6  1000 a  
##      eigen_chol  50.40  54.08  63.00  56.17  60.12  1247.6  1000 a
</code></pre>

<p>It&#39;s easy to beat <code>lm.fit</code>, but it&#39;s great to see considerable gains
with Eigen over LAPACK. The use of the Cholesky decomposition is
somewhat faster than QR decomposition, but it can&#39;t be used in the
rank-deficient case.</p>

<h2>Rank-deficient case</h2>

<p>Let&#39;s now consider a rank-deficient case. We use an example from 
<a href="http://www.jstatsoft.org/v52/i05/">Bates and Eddelbuettel (2013)</a>
(the <a href="https://github.com/RcppCore/RcppEigen">RcppEigen</a> paper).</p>

<pre><code class="r">dd &lt;- data.frame(f1 = gl(4, 6, labels = LETTERS[1:4]),
                 f2 = gl(3, 2, labels = letters[1:3]))[-(7:8), ]
mm &lt;- model.matrix(~ f1*f2, dd)
y &lt;- mm %*% seq_len(ncol(mm)) + rnorm(nrow(mm), sd = 0.1)
Y &lt;- as.matrix(y)
</code></pre>

<p>And here are the benchmark results.</p>

<pre><code class="r">microbenchmark(lmfit=       lm.fit(mm, y),
               dgels=       qtl2:::calc_rss_lapack(mm, Y),
               dgelsy=      qtl2:::calc_rss_lapack(mm, Y, skip_dgels=TRUE),
               eigen_qr_rss=qtl2:::calc_rss_eigenqr(mm, y),
               eigen_qr=    qtl2:::fit_linreg_eigenqr(mm, y),
               times=1000)
</code></pre>

<pre><code>## Unit: microseconds
##          expr    min     lq   mean median     uq    max neval  cld
##         lmfit 101.01 113.26 117.46 115.78 119.35  226.7  1000    d
##         dgels  54.36  58.25  61.49  60.59  64.62   90.2  1000   c 
##        dgelsy  44.35  48.07  53.55  50.30  54.27 2215.2  1000  b  
##  eigen_qr_rss  34.85  38.96  42.54  41.15  45.21  136.6  1000 a   
##      eigen_qr  40.55  45.04  53.55  47.78  52.16 2182.9  1000  b
</code></pre>

<p>We skip the methods based on Cholesky decomposition, but we again see
performance gains with Eigen over LAPACK.</p>

<p><code>dgels</code> is slower than <code>dgelsy</code> here, because with that routine, I&#39;m
calling <code>dgels</code> to check the matrix rank and then switch to <code>dgelsy</code>
if the matrix is rank-deficient.</p>

<h2>Bigger matrix</h2>

<p>Let&#39;s consider a bigger matrix, with 2,500 rows and 300 columns. I
don&#39;t want it to be too big, or compiling this vignette will take too
long. Try this yourself with bigger matrices, if you want.</p>

<pre><code class="r">n &lt;- 2500
p &lt;- 300
X &lt;- matrix(rnorm(n*p), nrow=n)
y &lt;- X %*% runif(p) + rnorm(n)
Y &lt;- as.matrix(y)
</code></pre>

<p>We use the full set again, as we can assume this to be a full-rank
case. But we&#39;ll just do 10 replicates.</p>

<pre><code class="r">microbenchmark(lmfit =        lm.fit(X, y),
               dgels=         qtl2:::calc_rss_lapack(X, Y),
               dgelsy=        qtl2:::calc_rss_lapack(X, Y, skip_dgels=TRUE),
               eigen_qr_rss=  qtl2:::calc_rss_eigenqr(X, y),
               eigen_qr=      qtl2:::fit_linreg_eigenqr(X, y),
               eigen_chol_rss=qtl2:::calc_rss_eigenchol(X, y),
               eigen_chol=    qtl2:::fit_linreg_eigenchol(X, y),
               times=10)
</code></pre>

<pre><code>## Unit: milliseconds
##            expr    min     lq   mean median     uq    max neval   cld
##           lmfit 237.51 239.20 251.82 239.95 244.61 300.61    10    d 
##           dgels 264.18 264.67 266.11 265.70 267.03 269.52    10    de
##          dgelsy 276.09 276.60 278.12 277.99 278.45 282.86    10     e
##    eigen_qr_rss 142.49 142.78 143.35 143.33 143.86 144.10    10  b   
##        eigen_qr 172.75 173.23 180.64 174.68 176.52 233.07    10   c  
##  eigen_chol_rss  32.49  32.62  33.05  32.63  32.83  35.70    10 a    
##      eigen_chol  37.04  37.27  38.28  37.64  37.76  41.57    10 a
</code></pre>

<h2>Multiple phenotypes</h2>

<p>We&#39;ll go back to the case with a single covariate, but we&#39;ll consider
500 phenotypes. We have a few routines to handle this, focusing
solely on calculating the residual sum of squares for each phenotype.</p>

<pre><code class="r">n &lt;- 1000
x &lt;- rnorm(n, 50, 10)
X &lt;- cbind(1, x)
y &lt;- 30 + 0.5*x + rnorm(n, 0, 2.5)
Y &lt;- qtl2:::permute_nvector(500, y)
</code></pre>

<p>Now we&#39;ll get the benchmarks.</p>

<pre><code class="r">microbenchmark(lmfit =    colSums(lm.fit(X, Y)$resid^2),
               dgels=     qtl2:::calc_rss_lapack(X, Y),
               dgelsy=    qtl2:::calc_rss_lapack(X, Y, skip_dgels=TRUE),
               eigen_qr=  qtl2:::calc_mvrss_eigenqr(X, Y),
               eigen_chol=qtl2:::calc_mvrss_eigenchol(X, Y),
               times=50)
</code></pre>

<pre><code>## Unit: milliseconds
##        expr    min     lq   mean median     uq    max neval cld
##       lmfit 14.922 74.669 73.698 75.877 77.176 79.427    50   b
##       dgels  5.265  5.605  5.838  5.834  5.970  6.620    50  a 
##      dgelsy  5.295  5.681  5.872  5.852  6.019  6.941    50  a 
##    eigen_qr  5.398  5.749  6.230  6.094  6.466 11.062    50  a 
##  eigen_chol  5.082  5.442  5.749  5.634  5.932  7.921    50  a
</code></pre>

<h2>Multiple phenotypes, rank-deficient matrix</h2>

<p>Let&#39;s do the same thing with a rank-deficient matrix.</p>

<pre><code class="r">dd &lt;- data.frame(f1 = gl(4, 6, labels = LETTERS[1:4]),
                 f2 = gl(3, 2, labels = letters[1:3]))[-(7:8), ]
mm &lt;- model.matrix(~ f1*f2, dd)
y &lt;- mm %*% seq_len(ncol(mm)) + rnorm(nrow(mm), sd = 0.1)
Y &lt;- qtl2:::permute_nvector(500, y)
</code></pre>

<p>And here are the benchmarks.</p>

<pre><code class="r">microbenchmark(lmfit =    colSums(lm.fit(mm, Y)$resid^2),
               dgels=     qtl2:::calc_rss_lapack(mm, Y),
               dgelsy=    qtl2:::calc_rss_lapack(mm, Y, skip_dgels=TRUE),
               eigen_qr=  qtl2:::calc_mvrss_eigenqr(mm, Y),
               times=100)
</code></pre>

<pre><code>## Unit: microseconds
##      expr    min     lq   mean median     uq  max neval  cld
##     lmfit 1125.7 1149.0 1359.2 1180.4 1365.9 5165   100    d
##     dgels 1137.6 1146.0 1173.2 1152.9 1180.3 1369   100   c 
##    dgelsy  717.8  720.1  740.3  724.6  745.1  985   100 a   
##  eigen_qr  814.2  847.6  897.3  862.2  898.8 1407   100  b
</code></pre>

<h2>Session information</h2>

<p>The following shows the R and package versions I was using.</p>

<pre><code class="r">devtools::session_info()
</code></pre>

<pre><code>## Session info--------------------------------------------------------------
</code></pre>

<pre><code>##  setting  value                       
##  version  R version 3.1.1 (2014-07-10)
##  system   x86_64, darwin13.1.0        
##  ui       X11                         
##  language en                          
##  collate  C                           
##  tz       America/Chicago
</code></pre>

<pre><code>## Packages------------------------------------------------------------------
</code></pre>

<pre><code>##  package        * version date       source        
##  MASS             7.3.35  2014-09-30 CRAN (R 3.1.1)
##  Rcpp             0.11.3  2014-09-29 CRAN (R 3.1.1)
##  TH.data          1.0.3   2014-01-15 CRAN (R 3.1.0)
##  assertthat       0.1     2013-12-06 CRAN (R 3.1.0)
##  broman         * 0.49.2  2014-09-17 local         
##  colorspace       1.2.4   2013-09-30 CRAN (R 3.1.0)
##  devtools         1.6     2014-09-23 CRAN (R 3.1.1)
##  digest           0.6.4   2013-12-03 CRAN (R 3.1.0)
##  evaluate         0.5.5   2014-04-29 CRAN (R 3.1.0)
##  formatR          1.0     2014-08-25 CRAN (R 3.1.1)
##  ggplot2          1.0.0   2014-05-21 CRAN (R 3.1.0)
##  gtable           0.1.2   2012-12-05 CRAN (R 3.1.0)
##  knitr          * 1.6     2014-05-25 CRAN (R 3.1.1)
##  lattice          0.20.29 2014-04-04 CRAN (R 3.1.0)
##  magrittr       * 1.0.1   2014-05-15 CRAN (R 3.1.0)
##  microbenchmark * 1.4.2   2014-09-28 CRAN (R 3.1.1)
##  multcomp         1.3.7   2014-10-02 CRAN (R 3.1.1)
##  munsell          0.4.2   2013-07-11 CRAN (R 3.1.0)
##  mvtnorm          1.0.0   2014-07-08 CRAN (R 3.1.1)
##  plyr             1.8.1   2014-02-26 CRAN (R 3.1.0)
##  proto            0.3.10  2012-12-22 CRAN (R 3.1.0)
##  qtl            * 1.34.4  2014-10-07 local         
##  qtl2           * 0.1.8   2014-10-10 local         
##  reshape2         1.4     2014-04-23 CRAN (R 3.1.0)
##  rstudioapi       0.1     2014-03-27 CRAN (R 3.1.0)
##  sandwich         2.3.2   2014-08-24 CRAN (R 3.1.1)
##  scales           0.2.4   2014-04-22 CRAN (R 3.1.0)
##  stringr          0.6.2   2012-12-06 CRAN (R 3.1.0)
##  survival         2.37.7  2014-01-22 CRAN (R 3.1.0)
##  zoo              1.7.11  2014-02-27 CRAN (R 3.1.0)
</code></pre>

<!-- the following to make it look nicer -->

<p><link href="http://kbroman.org/qtlcharts/assets/vignettes/vignette.css" rel="stylesheet"></link></p>

</body>

</html>
